/**
 * @file path_smoother.hpp
 * @brief Path smoothing algorithms for robot navigation
 *
 * Provides spline interpolation and smoothing for rough waypoint paths
 * generated by high-level planners.
 *
 * @author Rugved Raote
 * @copyright 2025 AgentFleet Project
 */

#ifndef AGENTFLEET_PATH_SMOOTHER_HPP
#define AGENTFLEET_PATH_SMOOTHER_HPP

#include <array>
#include <cmath>
#include <vector>


namespace agentfleet {

/**
 * @brief Path smoothing configuration
 */
struct SmoothingConfig {
  int interpolation_points = 10; ///< Points to insert between waypoints
  double tension = 0.5;          ///< Spline tension (0.0 to 1.0)
  double max_deviation = 0.5; ///< Maximum deviation from original path (meters)
};

/**
 * @brief Catmull-Rom spline interpolation for path smoothing
 *
 * Creates smooth curves through a series of waypoints using
 * Catmull-Rom spline interpolation.
 *
 * @param waypoints Input waypoints as [x, y] pairs
 * @param points_per_segment Number of interpolation points between waypoints
 * @return Smoothed path with additional interpolated points
 *
 * @code
 * std::vector<std::array<double, 2>> path = {{0, 0}, {5, 5}, {10, 0}};
 * auto smoothed = smooth_path(path, 10);
 * // smoothed now contains ~21 points forming a smooth curve
 * @endcode
 */
std::vector<std::array<double, 2>>
smooth_path(const std::vector<std::array<double, 2>> &waypoints,
            int points_per_segment = 10);

/**
 * @brief Bezier curve smoothing
 *
 * Uses quadratic Bezier curves to smooth sharp corners in paths.
 *
 * @param waypoints Input waypoints
 * @param tension Control point tension (0.0 = sharp, 1.0 = smooth)
 * @return Smoothed path
 */
std::vector<std::array<double, 2>>
bezier_smooth(const std::vector<std::array<double, 2>> &waypoints,
              double tension = 0.5);

/**
 * @brief Moving average filter for path smoothing
 *
 * Simple smoothing using a sliding window average.
 * Fast but may deviate from original path.
 *
 * @param waypoints Input waypoints
 * @param window_size Number of points to average
 * @return Smoothed path (same number of points)
 */
std::vector<std::array<double, 2>>
moving_average_smooth(const std::vector<std::array<double, 2>> &waypoints,
                      int window_size = 3);

/**
 * @brief Calculate total path length
 * @param waypoints Path as [x, y] pairs
 * @return Total length in meters
 */
double path_length(const std::vector<std::array<double, 2>> &waypoints);

/**
 * @brief Resample path to have uniform point spacing
 * @param waypoints Input path
 * @param target_spacing Desired distance between points (meters)
 * @return Resampled path with uniform spacing
 */
std::vector<std::array<double, 2>>
resample_path(const std::vector<std::array<double, 2>> &waypoints,
              double target_spacing = 0.5);

/**
 * @brief Check if path makes a sharp turn at a waypoint
 * @param p1 Previous point
 * @param p2 Current point
 * @param p3 Next point
 * @param threshold Angle threshold in radians (default: 45 degrees)
 * @return true if turn angle exceeds threshold
 */
bool is_sharp_turn(const std::array<double, 2> &p1,
                   const std::array<double, 2> &p2,
                   const std::array<double, 2> &p3,
                   double threshold = M_PI / 4.0);

} // namespace agentfleet

#endif // AGENTFLEET_PATH_SMOOTHER_HPP
